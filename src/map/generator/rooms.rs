use rand::{StdRng, Rng};

use super::MapGenerator;
use map::*;

impl MapGenerator {
    pub(in super) fn generate_rooms(&self, rng: &mut StdRng, map: &mut FloorMap, level: usize) -> Vec<(RoomId, Room)> {
        let mut rooms = self.generate_special_rooms(rng, map, level);

        while rooms.len() < self.rooms {
            let room = self.place_room(&rooms, || self.random_room(rng, RoomType::Normal));
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        rooms
    }

    fn generate_special_rooms(&self, rng: &mut StdRng, map: &mut FloorMap, level: usize) -> Vec<(RoomId, Room)> {
        let mut rooms = Vec::new();

        // If we're on the first level, generate the room where the player will spawn
        if level == 1 {
            let room = self.place_room(&rooms, || self.random_room(rng, RoomType::PlayerStart));
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        // If we're on the last level, generate the treasure chamber
        if level == self.levels {
            let room = self.place_room(&rooms, || {
                let pos = TilePos {
                    row: rng.gen_range(0, self.rows),
                    col: rng.gen_range(0, self.cols),
                };
                let size = GridSize {
                    rows: self.treasure_chamber_height,
                    cols: self.treasure_chamber_width,
                };
                Room::with_type(RoomType::TreasureChamber, pos, size)
            });
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        rooms
    }

    fn random_room(&self, rng: &mut StdRng, rtype: RoomType) -> Room {
        let pos = TilePos {
            row: rng.gen_range(0, self.rows),
            col: rng.gen_range(0, self.cols),
        };
        let size = GridSize {
            rows: self.room_rows.gen(rng),
            cols: self.room_cols.gen(rng),
        };
        Room::with_type(rtype, pos, size)
    }

    /// Attempts to place one of the rooms generated by room_gen. Stops and returns the first room
    /// that is able to be placed. Will loop forever if no fitting room is ever generated.
    fn place_room<R>(&self, rooms: &[(RoomId, Room)], mut room_gen: R) -> Room
        where R: FnMut() -> Room {
        'find_rooms: loop {
            let room = room_gen();

            // Ensure that the room is within the bounds
            let bottom_right = room.bottom_right();
            if bottom_right.row >= self.rows || bottom_right.col >= self.cols {
                continue;
            }

            // Ensure no overlap with any other room
            for (_, other_room) in rooms {
                // Rooms cannot be directly adjacent to each other, this makes enough room for a
                // passage to come through
                let other_room = other_room.expand(self.passage_size);
                if room.has_intersection(other_room) {
                    continue 'find_rooms;
                }
            }
            return room;
        }
    }

    /// Places each room onto the map itself
    pub(in super) fn place_rooms(
        &self,
        map: &mut FloorMap,
        rooms: &[(RoomId, Room)],
        sprite: SpriteImage,
    ) {
        for &(room_id, ref room) in rooms {
            for pos in room.tile_positions() {
                map.place_tile(pos, TileType::Room(room_id), sprite);
            }

            // Open walls to all adjacent tiles with the same room ID
            for pos in room.tile_positions() {
                // NOTE: There is room for optimization here because we are actually opening
                // walls that will have already been opened on a previous iteration.

                // Need to collect in order to avoid mutable + immutable borrow
                let adjacents = map.adjacent_positions(pos)
                    .filter(|&adj| map.is_room_id(adj, room_id))
                    .collect::<Vec<_>>();
                for adj in adjacents {
                    map.open_between(pos, adj);
                }
            }
        }
    }
}
