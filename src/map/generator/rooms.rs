use rand::{StdRng, Rng};

use super::MapGenerator;
use map::*;

impl MapGenerator {
    pub(in super) fn generate_rooms(&self, rng: &mut StdRng, map: &mut FloorMap, level: usize) -> Vec<(RoomId, Room)> {
        let mut rooms = self.generate_special_rooms(rng, map, level);

        while rooms.len() < self.rooms {
            let room = self.place_room(&rooms, || self.random_room(rng, RoomType::Normal));
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        rooms
    }

    fn generate_special_rooms(&self, rng: &mut StdRng, map: &mut FloorMap, level: usize) -> Vec<(RoomId, Room)> {
        let mut rooms = Vec::new();

        // If we're on the first level, generate the room where the player will spawn
        if level == 1 {
            let room = self.place_room(&rooms, || self.random_room(rng, RoomType::PlayerStart));
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        // If we're on the last level, generate the treasure chamber
        if level == self.levels {
            let room = self.place_room(&rooms, || {
                let x = rng.gen_range(0, self.cols);
                let y = rng.gen_range(0, self.rows);
                Room::with_type(RoomType::TreasureChamber, x, y,
                    self.treasure_chamber_width, self.treasure_chamber_height)
            });
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        rooms
    }

    fn random_room(&self, rng: &mut StdRng, rtype: RoomType) -> Room {
        let x = rng.gen_range(0, self.cols);
        let y = rng.gen_range(0, self.rows);
        let width = self.room_width.gen(rng);
        let height = self.room_height.gen(rng);
        Room::with_type(rtype, x, y, width, height)
    }

    /// Attempts to place one of the rooms generated by room_gen. Stops and returns the first room
    /// that is able to be placed. Will loop forever if no fitting room is ever generated.
    fn place_room<R>(&self, rooms: &[(RoomId, Room)], mut room_gen: R) -> Room
        where R: FnMut() -> Room {
        'find_rooms: loop {
            let room = room_gen();

            // Ensure that the room is within the bounds
            if room.x() + room.width() >= self.cols || room.y() + room.height() >= self.rows {
                continue;
            }

            // Ensure no overlap with any other room
            for (_, other_room) in rooms {
                // Rooms cannot be directly adjacent to each other, this makes enough room for a
                // passage to come through
                let other_room = other_room.expand(self.passage_size);
                if room.has_intersection(other_room) {
                    continue 'find_rooms;
                }
            }
            return room;
        }
    }

    /// Places each room onto the map itself
    pub(in super) fn place_rooms(&self, map: &mut FloorMap, rooms: &[(RoomId, Room)]) {
        for &(room_id, ref room) in rooms {
            for row_i in room.y()..(room.y() + room.height()) {
                for col_i in room.x()..(room.x() + room.width()) {
                    map.place_tile((row_i, col_i), TileType::Room(room_id));
                }
            }

            // Open walls to all adjacent tiles with the same room ID
            for row_i in room.y()..(room.y() + room.height()) {
                for col_i in room.x()..(room.x() + room.width()) {
                    // NOTE: There is room for optimization here because we are actually opening
                    // walls that will have already been opened on a previous iteration.

                    // Need to collect in order to avoid mutable + immutable borrow
                    let adjacents = map.adjacent_positions((row_i, col_i))
                        .filter(|&adj| map.is_room_id(adj, room_id))
                        .collect::<Vec<_>>();
                    for adj in adjacents {
                        map.open_between((row_i, col_i), adj);
                    }
                }
            }
        }
    }
}
